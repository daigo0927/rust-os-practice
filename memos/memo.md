# フリースタンディングなRustバイナリ

## `sh_personality` Language Item

- language itemはコンパイラが内部的に必要とする特別な関数や型。`eh_personality` language itemは、スタックアンワインドを実装するための関数を定義する。

## リンカエラー

- リンカはコードを実行可能ファイルに紐つけるプログラム。デフォルトの設定では、リンカはCランタイムの起動ルーチンを含んでいる。今回はベアメタル環境での実行を実施するため、Cランタイムへの依存は回避したい。

---

# Rustで作る最小のカーネル

## 起動（Boot）のプロセス

コンピュータを起動すると、マザーボードのROMに保存されたファームウェアのコードが実行される。このコードはRAMの検出やCPUなどハードウェアの初期化し、その後ブート可能ディスクを探す。ファームウェアの規格にはBIOSとUEFIがある。

ディスクが見つかると、ブートローダーと呼ばれる先頭512バイトに保存された実行可能コードへと操作権が移る。ブートローダーはディスク内のカーネルイメージの場所を特定し、メモリに読み込む。またCPUを64bitのロングモードに変更し、64bitレジスタと全てのメインメモリを利用可能にする。そしてメモリーマップなどの特定の情報をBIOSから聞き出し、OSのカーネルに渡す。

### Multiboot標準規格

- カーネル：OSの中核となるソフトウェア。プログラムの実行管理や、ハードウェアへのアクセス提供などを行う。
- Linuxで人気のブートローダーとしては、GNU GRUBなどがある。
- ブートローダーの標準規格として、フリーソフトウェア財団がMultibootと言う規格を策定している。

## 最小のカーネル

- SIMD(Single Instruction Mutiple Data)：コンピュータやプロセッサで並列処理を行うための設計様式の一つ。プログラムを高速化してくれる場面が多いが、OSカーネル上で使うと性能への悪影響がありえるので、今回は無効化する。

### 画面に出力する

`unsafe`ブロックはRustでのプログラミング時にはできるだけ避けたい。このためには、Rustでは安全なabstractionを作ることができる。これにunsafeな操作をカプセル化することで、外部からの誤った操作を防ぐことができる。

## カーネルを実行する

### ブートイメージを作る

`bootimage`ツールによって、`bootloader`クレートをスタンドアロンの実行ファイルとしてコンパイルし、カーネルのELFファイルのバイト列をブートローダーにリンクする。

起動時には、ブートローダーは追加されたELFファイルを読み込み、解釈する。次にプログラムをページテーブルの仮装アドレスにマップし、`.bss`部をゼロにし、スタックをセットアップする。最後にエントリポイントのアドレス（`_start`関数）を読み、そこにジャンプする。

---

# VGAテキストモード

## Rustのモジュール

### テキストバッファ

VGAバッファへの参照は`buffer`に格納される。この参照がどのくらい有効かをコンパイラに伝えるために、明示的なライフタイムが必要になる。`'static`ライフタイムは、その参照がプログラムの実行中ずっと有効であることを指定している。

```rust
// in src/vga_buffer.rs

pub struct Writer {
    column_position: usize,
    color_code: ColorCode,
    buffer: &'static mut Buffer,
}
```

### Volatile

- volatileな書き込み：この書き込みに副作用があること。今回は最適化により取り除かれるべきでは無いとコンパイラに命令する必要があるため、`volatile`ライブラリ（クレート）を使う。`volatile::Volatile`というラッパー型は`read, write`というメソッドを提供しており、読み込み・書き込みが最適化により取り除かれないことを保証する。

## 大域的（global）なインターフェース

### Lazyな静的変数

定数でない関数で一度だけ静的変数を初期化したい場合がある。こうした時は`lazy_static`クレートを用いることで、初期化が後回しにされる`static`を定義する、`lazy_static!`マクロを提供する。これによって静的な`WRITER`を問題なく定義できる。

### スピンロック

同期された内部か変性を得るためには、標準ライブラリを使えるならMutexクレートが使える。これはリソースがすでにロックされていた場合、スレッドブロックによって相互排他性を提供する。

今回作るカーネルにはブロックやスレッドの概念がないので、OSを必要としない単純なmutexとして、スピンロックを用いる。スピンロックを用いることで、ブロックする代わりにリソースを何度もロックしようとする。これによってmutexが解放されるまでの間CPU時間を使い尽くす。

---

個人学習用のメモ。オリジナルのブログ投稿は[phil-opp/blog_osにてCC-BY-NC](https://github.com/phil-opp/blog_os/tree/main/blog/content#license)で公開されている。
