# フリースタンディングなRustバイナリ

## `sh_personality` Language Item

- language itemはコンパイラが内部的に必要とする特別な関数や型。`eh_personality` language itemは、スタックアンワインドを実装するための関数を定義する。

## リンカエラー

- リンカはコードを実行可能ファイルに紐つけるプログラム。デフォルトの設定では、リンカはCランタイムの起動ルーチンを含んでいる。今回はベアメタル環境での実行を実施するため、Cランタイムへの依存は回避したい。

---

# Rustで作る最小のカーネル

## 起動（Boot）のプロセス

コンピュータを起動すると、マザーボードのROMに保存されたファームウェアのコードが実行される。このコードはRAMの検出やCPUなどハードウェアの初期化し、その後ブート可能ディスクを探す。ファームウェアの規格にはBIOSとUEFIがある。

ディスクが見つかると、ブートローダーと呼ばれる先頭512バイトに保存された実行可能コードへと操作権が移る。ブートローダーはディスク内のカーネルイメージの場所を特定し、メモリに読み込む。またCPUを64bitのロングモードに変更し、64bitレジスタと全てのメインメモリを利用可能にする。そしてメモリーマップなどの特定の情報をBIOSから聞き出し、OSのカーネルに渡す。

### Multiboot標準規格

- カーネル：OSの中核となるソフトウェア。プログラムの実行管理や、ハードウェアへのアクセス提供などを行う。
- Linuxで人気のブートローダーとしては、GNU GRUBなどがある。
- ブートローダーの標準規格として、フリーソフトウェア財団がMultibootと言う規格を策定している。

## 最小のカーネル

- SIMD(Single Instruction Mutiple Data)：コンピュータやプロセッサで並列処理を行うための設計様式の一つ。プログラムを高速化してくれる場面が多いが、OSカーネル上で使うと性能への悪影響がありえるので、今回は無効化する。

### 画面に出力する

`unsafe`ブロックはRustでのプログラミング時にはできるだけ避けたい。このためには、Rustでは安全なabstractionを作ることができる。これにunsafeな操作をカプセル化することで、外部からの誤った操作を防ぐことができる。

## カーネルを実行する

### ブートイメージを作る

`bootimage`ツールによって、`bootloader`クレートをスタンドアロンの実行ファイルとしてコンパイルし、カーネルのELFファイルのバイト列をブートローダーにリンクする。

起動時には、ブートローダーは追加されたELFファイルを読み込み、解釈する。次にプログラムをページテーブルの仮装アドレスにマップし、`.bss`部をゼロにし、スタックをセットアップする。最後にエントリポイントのアドレス（`_start`関数）を読み、そこにジャンプする。

---

# VGAテキストモード

## Rustのモジュール

### テキストバッファ

VGAバッファへの参照は`buffer`に格納される。この参照がどのくらい有効かをコンパイラに伝えるために、明示的なライフタイムが必要になる。`'static`ライフタイムは、その参照がプログラムの実行中ずっと有効であることを指定している。

```rust
// in src/vga_buffer.rs

pub struct Writer {
    column_position: usize,
    color_code: ColorCode,
    buffer: &'static mut Buffer,
}
```

### Volatile

- volatileな書き込み：この書き込みに副作用があること。今回は最適化により取り除かれるべきでは無いとコンパイラに命令する必要があるため、`volatile`ライブラリ（クレート）を使う。`volatile::Volatile`というラッパー型は`read, write`というメソッドを提供しており、読み込み・書き込みが最適化により取り除かれないことを保証する。

## 大域的（global）なインターフェース

### Lazyな静的変数

定数でない関数で一度だけ静的変数を初期化したい場合がある。こうした時は`lazy_static`クレートを用いることで、初期化が後回しにされる`static`を定義する、`lazy_static!`マクロを提供する。これによって静的な`WRITER`を問題なく定義できる。

### スピンロック

同期された内部か変性を得るためには、標準ライブラリを使えるならMutexクレートが使える。これはリソースがすでにロックされていた場合、スレッドブロックによって相互排他性を提供する。

今回作るカーネルにはブロックやスレッドの概念がないので、OSを必要としない単純なmutexとして、スピンロックを用いる。スピンロックを用いることで、ブロックする代わりにリソースを何度もロックしようとする。これによってmutexが解放されるまでの間CPU時間を使い尽くす。

---

# テスト

## コンソールに出力する

### タイムアウト

`cargo test`はテストランナーが終了するまで待つので、終了しないテストがあるとテストランナーを永遠にブロックしかねない。今回は以下のようなケースで無限ループが発生し得る。

- ブートローダーがカーネル読み込みに失敗し、システムが再起動し続ける
- BIOS/UEFIファームウェアがブートローダーの読み込みに失敗し、再起動し続ける
- 作った関数のどれかの最後で、CPUが`loop {}`文に入ってしまう（例えばQEMU終了デバイスがうまく動かなかったなどの理由）
- CPU例外がうまく捕捉されなかった場合などに、ハードウェアがシステムリセットを行う

これに対して、今回使っている`bootimage`クレートは標準で5分のタイムアウトを設定している。テストがこの時間内に終了しなかった場合は失敗とみなされ、"Timed Out"エラーがコンソールに表示される。

## 結合テスト

### ライブラリを作る

結合テストに必要な関数を利用するために、`main.rs`から必要なライブラリを`src/lib.rs`として分離する。`lib.rs`は`main.rs`と同様に、cargoから認識される特別なファイルである。`cargo test`コマンドからもライブラリを使うため、テストのための関数や属性を`main.rs`から`lib.rs`へ移した。

---

# CPU例外

## 概要

例外は実行している命令が異常であることを示す。例えばゼロ除算を実行しようとしている時、CPUは例外を発する。例外が起こると、CPUは現在行われている作業に割り込み、例外の種類によって特定の例外ハンドラ関数を呼ぶ。

x86には20種類のCPU例外があり、重要なものとしては以下がある。

- ページフォルト：不正なメモリアクセス時に発生。読み込み専用ページへの書き込みなど
- 無効な命令コード：旧式CPUで、サポートしていない新しい命令を実行しようとした時など
- 一般保護違反：いろいろな種類のアクセス違反で発生
- ダブルフォルト：何らかの例外が起き、CPUガレ以外ハンドラを呼び出しているときに別の例外が起こった場合に発生
- トリプルフォルト：CPUがダブルフォルトのハンドラ関数を呼び出そうとしている間に、さらに例外が起こった場合に発生。トリプルフォルトを捕捉したり処理することはできず、多くのプロセッサは自らをリセットしてOS再起動を実行する。

### 割り込み呼び出し規約

例外を捕捉し処理するためには、割り込み記述子表（IDT：Interrupt Descriptor Table）を設定する必要がある。ハードウェアはこの表を直接使うので、決められたフォーマットに従う必要がある。

例外発生時に、CPUはざっくり以下を行う。

1. 命令ポインタとRFLAGSレジすらを含むレジスタをスタックにプッシュする
2. 割り込み記述子表から対応するエントリをよみ、例えば、ページフォルトが起こったときはCPUは十四番目のエントリを読む
3. エントリが存在しているかチェックする。そうでなければダブルフォルトを起こす
4. エントリが割り込みゲート（40番目のビットがゼロ）ならハードウェア割り込みを無効にする
5. 指定されたGDT（大域記述子表）セレクタをCSセグメントに読み込む
6. 指定されたハンドラ関数にジャンプする

## 例外の呼び出し規約

例外と関数呼び出しは似ている。CPUが呼び出された関数の最初の命令にジャンプし、それを実行する。その後CPUはリターンアドレスにジャンプし、親関数の実行を続ける。

一方で、例外と関数呼び出しの大きな違いとして、例外はどんな命令の実行中でも起こる可能性がある。

呼び出し規約は、関数呼び出しについて細かく指定している。例えば関数のパラメータがどこ（スタック、レジスタ、など）に置かれるべきか、結果がどのように返されるべきか、などを指定している。

### PreservedレジスタとScratchレジスタ

呼び出し規約はレジスタをpreserved（保存）レジスタとscratch（下書き）レジスタの2種類に分けている。preservedレジスタは関数呼び出しの前後で変化してはいけない。対してscratchレジスタは呼び出された関数から、何の制約もなく上書きできる。

x86_64においては、C言語の呼び出し規約は以下のpreserved, scratchレジスタを指定する。

| **preservedレジスタ** | **scratchレジスタ** |
|:-:|:-:|
| `rbp, rbx, rsp, r12, r13, r14, r15` | `rax, rcx, rdx, rsi, rdi, r8, r9, r10, r11` |
| *callee-saved*  | *caller-saved*  |

コンパイラはこれらのルールを知っているため、それに従ってコードを生成する。

一方で、例外はどんな命令の最中にも起きる可能性がある。多くの場合、生成されたコードが例外を引き起こすのかどうかは、コンパイル時には検討もつかない。よってレジスタを事前にバックアップしておくことは不可能となる。代わりに全てのレジスタを保存する規約を使う必要がある。

`x86-interrupt`呼び出し規約はそのような呼び出し規約なので、関数が戻るときに全てのレジスタが元の値に戻されることを保証してくれる。複雑な例外処理プロセスを隠蔽してくれる、強力な抽象化と言える。

---

個人学習用のメモ。オリジナルのブログ投稿は[phil-opp/blog_osにてCC-BY-NC](https://github.com/phil-opp/blog_os/tree/main/blog/content#license)で公開されている。
