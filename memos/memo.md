# フリースタンディングなRustバイナリ

## `sh_personality` Language Item

- language itemはコンパイラが内部的に必要とする特別な関数や型。`eh_personality` language itemは、スタックアンワインドを実装するための関数を定義する。

## リンカエラー

- リンカはコードを実行可能ファイルに紐つけるプログラム。デフォルトの設定では、リンカはCランタイムの起動ルーチンを含んでいる。今回はベアメタル環境での実行を実施するため、Cランタイムへの依存は回避したい。

---

# Rustで作る最小のカーネル

## 起動（Boot）のプロセス

コンピュータを起動すると、マザーボードのROMに保存されたファームウェアのコードが実行される。このコードはRAMの検出やCPUなどハードウェアの初期化し、その後ブート可能ディスクを探す。ファームウェアの規格にはBIOSとUEFIがある。

ディスクが見つかると、ブートローダーと呼ばれる先頭512バイトに保存された実行可能コードへと操作権が移る。ブートローダーはディスク内のカーネルイメージの場所を特定し、メモリに読み込む。またCPUを64bitのロングモードに変更し、64bitレジスタと全てのメインメモリを利用可能にする。そしてメモリーマップなどの特定の情報をBIOSから聞き出し、OSのカーネルに渡す。

### Multiboot標準規格

- カーネル：OSの中核となるソフトウェア。プログラムの実行管理や、ハードウェアへのアクセス提供などを行う。
- Linuxで人気のブートローダーとしては、GNU GRUBなどがある。
- ブートローダーの標準規格として、フリーソフトウェア財団がMultibootと言う規格を策定している。

## 最小のカーネル

- SIMD(Single Instruction Mutiple Data)：コンピュータやプロセッサで並列処理を行うための設計様式の一つ。プログラムを高速化してくれる場面が多いが、OSカーネル上で使うと性能への悪影響がありえるので、今回は無効化する。

### 画面に出力する

`unsafe`ブロックはRustでのプログラミング時にはできるだけ避けたい。このためには、Rustでは安全なabstractionを作ることができる。これにunsafeな操作をカプセル化することで、外部からの誤った操作を防ぐことができる。

## カーネルを実行する

### ブートイメージを作る

`bootimage`ツールによって、`bootloader`クレートをスタンドアロンの実行ファイルとしてコンパイルし、カーネルのELFファイルのバイト列をブートローダーにリンクする。

起動時には、ブートローダーは追加されたELFファイルを読み込み、解釈する。次にプログラムをページテーブルの仮装アドレスにマップし、`.bss`部をゼロにし、スタックをセットアップする。最後にエントリポイントのアドレス（`_start`関数）を読み、そこにジャンプする。

---

# VGAテキストモード

## Rustのモジュール

### テキストバッファ

VGAバッファへの参照は`buffer`に格納される。この参照がどのくらい有効かをコンパイラに伝えるために、明示的なライフタイムが必要になる。`'static`ライフタイムは、その参照がプログラムの実行中ずっと有効であることを指定している。

```rust
// in src/vga_buffer.rs

pub struct Writer {
    column_position: usize,
    color_code: ColorCode,
    buffer: &'static mut Buffer,
}
```

### Volatile

- volatileな書き込み：この書き込みに副作用があること。今回は最適化により取り除かれるべきでは無いとコンパイラに命令する必要があるため、`volatile`ライブラリ（クレート）を使う。`volatile::Volatile`というラッパー型は`read, write`というメソッドを提供しており、読み込み・書き込みが最適化により取り除かれないことを保証する。

## 大域的（global）なインターフェース

### Lazyな静的変数

定数でない関数で一度だけ静的変数を初期化したい場合がある。こうした時は`lazy_static`クレートを用いることで、初期化が後回しにされる`static`を定義する、`lazy_static!`マクロを提供する。これによって静的な`WRITER`を問題なく定義できる。

### スピンロック

同期された内部か変性を得るためには、標準ライブラリを使えるならMutexクレートが使える。これはリソースがすでにロックされていた場合、スレッドブロックによって相互排他性を提供する。

今回作るカーネルにはブロックやスレッドの概念がないので、OSを必要としない単純なmutexとして、スピンロックを用いる。スピンロックを用いることで、ブロックする代わりにリソースを何度もロックしようとする。これによってmutexが解放されるまでの間CPU時間を使い尽くす。

---

# テスト

## コンソールに出力する

### タイムアウト

`cargo test`はテストランナーが終了するまで待つので、終了しないテストがあるとテストランナーを永遠にブロックしかねない。今回は以下のようなケースで無限ループが発生し得る。

- ブートローダーがカーネル読み込みに失敗し、システムが再起動し続ける
- BIOS/UEFIファームウェアがブートローダーの読み込みに失敗し、再起動し続ける
- 作った関数のどれかの最後で、CPUが`loop {}`文に入ってしまう（例えばQEMU終了デバイスがうまく動かなかったなどの理由）
- CPU例外がうまく捕捉されなかった場合などに、ハードウェアがシステムリセットを行う

これに対して、今回使っている`bootimage`クレートは標準で5分のタイムアウトを設定している。テストがこの時間内に終了しなかった場合は失敗とみなされ、"Timed Out"エラーがコンソールに表示される。

## 結合テスト

### ライブラリを作る

結合テストに必要な関数を利用するために、`main.rs`から必要なライブラリを`src/lib.rs`として分離する。`lib.rs`は`main.rs`と同様に、cargoから認識される特別なファイルである。`cargo test`コマンドからもライブラリを使うため、テストのための関数や属性を`main.rs`から`lib.rs`へ移した。

---

# CPU例外

## 概要

例外は実行している命令が異常であることを示す。例えばゼロ除算を実行しようとしている時、CPUは例外を発する。例外が起こると、CPUは現在行われている作業に割り込み、例外の種類によって特定の例外ハンドラ関数を呼ぶ。

x86には20種類のCPU例外があり、重要なものとしては以下がある。

- ページフォルト：不正なメモリアクセス時に発生。読み込み専用ページへの書き込みなど
- 無効な命令コード：旧式CPUで、サポートしていない新しい命令を実行しようとした時など
- 一般保護違反：いろいろな種類のアクセス違反で発生
- ダブルフォルト：何らかの例外が起き、CPUガレ以外ハンドラを呼び出しているときに別の例外が起こった場合に発生
- トリプルフォルト：CPUがダブルフォルトのハンドラ関数を呼び出そうとしている間に、さらに例外が起こった場合に発生。トリプルフォルトを捕捉したり処理することはできず、多くのプロセッサは自らをリセットしてOS再起動を実行する。

### 割り込み呼び出し規約

例外を捕捉し処理するためには、割り込み記述子表（IDT：Interrupt Descriptor Table）を設定する必要がある。ハードウェアはこの表を直接使うので、決められたフォーマットに従う必要がある。

例外発生時に、CPUはざっくり以下を行う。

1. 命令ポインタとRFLAGSレジすらを含むレジスタをスタックにプッシュする
2. 割り込み記述子表から対応するエントリをよみ、例えば、ページフォルトが起こったときはCPUは十四番目のエントリを読む
3. エントリが存在しているかチェックする。そうでなければダブルフォルトを起こす
4. エントリが割り込みゲート（40番目のビットがゼロ）ならハードウェア割り込みを無効にする
5. 指定されたGDT（大域記述子表）セレクタをCSセグメントに読み込む
6. 指定されたハンドラ関数にジャンプする

## 例外の呼び出し規約

例外と関数呼び出しは似ている。CPUが呼び出された関数の最初の命令にジャンプし、それを実行する。その後CPUはリターンアドレスにジャンプし、親関数の実行を続ける。

一方で、例外と関数呼び出しの大きな違いとして、例外はどんな命令の実行中でも起こる可能性がある。

呼び出し規約は、関数呼び出しについて細かく指定している。例えば関数のパラメータがどこ（スタック、レジスタ、など）に置かれるべきか、結果がどのように返されるべきか、などを指定している。

### PreservedレジスタとScratchレジスタ

呼び出し規約はレジスタをpreserved（保存）レジスタとscratch（下書き）レジスタの2種類に分けている。preservedレジスタは関数呼び出しの前後で変化してはいけない。対してscratchレジスタは呼び出された関数から、何の制約もなく上書きできる。

x86_64においては、C言語の呼び出し規約は以下のpreserved, scratchレジスタを指定する。

| **preservedレジスタ** | **scratchレジスタ** |
|:-:|:-:|
| `rbp, rbx, rsp, r12, r13, r14, r15` | `rax, rcx, rdx, rsi, rdi, r8, r9, r10, r11` |
| *callee-saved*  | *caller-saved*  |

コンパイラはこれらのルールを知っているため、それに従ってコードを生成する。

一方で、例外はどんな命令の最中にも起きる可能性がある。多くの場合、生成されたコードが例外を引き起こすのかどうかは、コンパイル時には検討もつかない。よってレジスタを事前にバックアップしておくことは不可能となる。代わりに全てのレジスタを保存する規約を使う必要がある。

`x86-interrupt`呼び出し規約はそのような呼び出し規約なので、関数が戻るときに全てのレジスタが元の値に戻されることを保証してくれる。複雑な例外処理プロセスを隠蔽してくれる、強力な抽象化と言える。

---

# Double Faults

## ダブルフォルトの原因

AMD64のマニュアルでは、ダブルフォルト例外の正確な定義として「ダブルフォルト例外は直前の（1度目）の例外ハンドラの処理中に2度目の例外が発生したとき起きうる」と書かれている。「起き得る」というのが重要で、実際には特別な例外の組み合わせでのみダブルフォルトとなる。

### カーネルスタックオーバーフロー

カーネルがスタックをオーバーフローさせて、ガードページにヒットした場合を考える。

ガードページはスタックの底にある特別なメモリページで、これによってスタックオーバーフローを検出できる。このページはどの物理メモリにもマップされていないので、アクセスしようとするとページフォルトが発生する。

ページフォルトが起きると、CPUはIDT内のページフォルトハンドラを探しに行き、割り込みスタックフレームをスタックにプッシュしようとする。しかし、このスタックポインタは存在しないガードページを指しているため、結果として2度目のページフォルトが発生し、ダブルフォルトとなる。

ここでCPUはダブルフォルトハンドラを呼びに行くが、ダブルフォルト例外においてもCPUは例外スタックフレームをプッシュしようと試みる。スタックポインタはまだガードページを指しているので、3度目のページフォルトが起き、トリプルフォルトとなる。結果としてシステムは再起動となる。

これに対処するには、ダブルフォルト例外が発生したとき、スタックが常に正常であることをどうにかして保証する必要がある。x86_64アーキテクチャは、スタックを切り替えることでこの問題に対応する。

## スタックを切り替える

x86_64アーキテクチャは例外発生時にあらかじめ定義されている基地の正常なスタックに切り替えることができる。この切り替えはハードウェアレベルで発生するので、CPUが例外スタックフレームをプッシュする前に行うことができる。

切り替えの仕組みは割り込みスタックテーブル（IST：Interrupt Stack Table）として実装されている。ISTは7つの基地の正常なポインタのテーブルであり、Rustの疑似コードで表すと以下のようになる。

```rust
struct InterruptStackTable {
    stack_pointers: [Option<StackPointer>; 7],
}
```

CPUがダブルフォルト起こした際には必ずこのスタックに自動的に切り替えを行う。この切り替えは何かがプッシュする前に起きるので、トリプルフォルトを防ぐことができる。

### ISTとTSS

割り込みスタックテーブル（IST）は、タスクステートセグメント（TSS）というレガシーな構造体の一部である。x86_64においてはTSSはタスク固有の情報は持たなくなり、代わりに2つのスタックテーブル（一つがIST）を持つようになった。

### グローバルディスクリプタテーブル

TSSを作ったので、CPUにそれを使うために教える方法が必要となる。TSSはセグメンテーションシステムを使うため、テーブルを直接読み込むのではなく、新しいセグメントディスクリプタをグローバルディスクリプタテーブル（GDT）に追加する必要がある。

- IDT（Interrupt Descriptor Table）：割り込みと割り込みハンドラ（対応する処理）を結びつけるテーブル
- IST（Interrupt Stack Table）：例外発生時に用いるための、既知の正常なスタックへのポインタ
- TSS（Task State Segment）：ISTを保持する構造体。他に特権スタックテーブルやI/Oマップベースアドレスも保持する。
- GDT（Global Descriptor Table）：メモリセグメンテーションのための仕組み。ページングがデファクトスタンダードになる前に使われていた。今でもカーネル・ユーザーモードの設定やTSSの読み込みなどを行うために必要。

---

# ハードウェア割り込み

## 概要

割り込みは、接続されたハードウェアデバイスからCPUに通知する方法を提供する。同様に、よって、例えばキーボードは各キーが押されたことをカーネルに通知できる。

全てのハードウェアデバイスをCPUに直接接続することはできないので、代わりに別の割り込みコントローラーが全てのデバイスからの割り込みを集約してからCPUに通知する。

```
                                    ____________             _____
               Timer ------------> |            |           |     |
               Keyboard ---------> | Interrupt  |---------> | CPU |
               Other Hardware ---> | Controller |           |_____|
               Etc. -------------> |____________|
```

## 8259 PIC

Intel 8259は、1976年に導入された、プログラム可能割り込みコントローラー（PIC）である。現在は新しいAPICがあるものの、下位互換性のために現在のシステムでもインターフェイスがサポートされている。

8259にはCPUと通信するための8本の割り込みラインと、その他複数のラインがある。当時の一般的なシステムには8259 PICの二つのインスタンスが装備されており、一つはプライマリPICで、もう一つはプライマリPICの割り込みラインの一つに接続されたセカンダリPICである。

```
                     ____________                          ____________
Real Time Clock --> |            |   Timer -------------> |            |
ACPI -------------> |            |   Keyboard-----------> |            |      _____
Available --------> | Secondary  |----------------------> | Primary    |     |     |
Available --------> | Interrupt  |   Serial Port 2 -----> | Interrupt  |---> | CPU |
Mouse ------------> | Controller |   Serial Port 1 -----> | Controller |     |_____|
Co-Processor -----> |            |   Parallel Port 2/3 -> |            |
Primary ATA ------> |            |   Floppy disk -------> |            |
Secondary ATA ----> |____________|   Parallel Port 1----> |____________|
```

各コントローラーは、二つのI/Oポート、一つのコマンドポートと一つのデータポートを介して構成できる。今回は`pic8259`クレートの`ChainedPics`を用いることで、上記のプライマリ/セカンダリPICレイアウトを構成する。

## キーボード入力

ハードウェアタイマーと同時に、キーボードコントローラーはデフォルトで有効になっている。
キーを押すとキーボードコントローラーはPICに割り込みを送信し、PICはそれをCPUに転送する。CPUはIDTでハンドラ関数を探すが、対応するエントリが空なため、現時点ではダブルフォルトとなる。よってキーボード割り込みのためのハンドラ関数が必要となる。

キーボード割り込みのハンドラ関数を実装すると、キーを押したタイミングで画面に「k」と表示される。ただし最初に押したキーのみに反応している。これは押されたキーのスキャンコードを読み取るまで、キーボードコントローラーが別の割り込みを送信しないためである。

### スキャンコードを読む

どのキーが押されたかを確認するには、キーボードコントローラに問い合わせる必要がある。PS/2コントローラのデータポート、今回は`0x60`番のI/Oポートからバイト（スキャンコード）を読み取ることで、これを行う。

### スキャンコードの解釈

スキャンコードはキーを押したタイミングと話したタイミングそれぞれに存在する。キーを表示するには、スキャンコードとキーのマッピングを把握する必要があり、これにはスキャンコードセットと呼ばれる3つの標準がある。

今回は`pc-keyboard`クレートを用いて、スキャンコードを翻訳する。

---

# ページング入門

## メモリの保護

オペレーティングシステムの主な役割の一つに、プログラムを違いに分離するということがある。例えば、ウェブブラウザがテキストエディタに干渉してはいけない。この目的のために、オペレーティングシステムはハードウェアの機能を利用して、あるプロセスのメモリ領域に他のプロセスがアクセスできないようにする。

x86_64アーキテクチャでは、ハードウェアは2つの異なるメモリ保護の方法をサポートしている。セグメンテーションとページングである。

## セグメンテーション

セグメンテーションは1978年にはすでに導入されており、当初の目的はアドレス可能なメモリ量を増やすことだった。セグメントレジスタが追加され、それぞれにオフセットアドレスを格納することで、CPUがメモリにアクセスするときに、広い範囲のメモリアドレスを扱えるようになった。

のちにプロテクトモードが導入されると、セグメントレジスタにはオフセットアドレスに加えて、セグメントのサイズとアクセス権限が可k農されるようになった。それぞれのプロセスに対してメモリアクセスをプロセスのメモリ領域のみに制限する（ような大域/局所ディスクリプタテーブル）をロードすることで、OSはプロセスを互いに分離出来るようになった。

メモリアドレスを実際にアクセスされる前に変更するという点において、セグメンテーションは仮想メモリのテクニックをすでに採用していたと言える。

### メモリ断片化（fragmentation）

物理アドレスと仮想アドレスを分けることで、セグメンテーションは強力なものとなった。一方で、物理上のメモリ領域が細切れになってしまう、メモリ断片化という問題が起きるようになった。

これにはプログラムを一時停止し、使用中のメモリ領域を整理して物理的に連続した空きメモリ領域を確保するデフラグ面テーションという処理で対応できるが、大量のメモリコピーが必要であり、パフォーマンスが低下してしまう。

実際、x86の64ビットモードではセグメンテーションはサポートされなくなり、ページングが使用されるようになった。これによって断片化の問題は完全に回避されるようになった。

## ページング

ページングの考え方は、仮想メモリ空間と物理メモリ空間の両方を、サイズの固定された小さなブロックに分割するというものである。仮想メモリ空間のブロックはページと呼ばれ、物理アドレス空間のブロックはフレームと呼ばれる。各ページはフレームに独立してマッピングできるので、大きなメモリ領域を連続していない物理フレームに分割することができる。

### 隠された断片化

少ない数の可変サイズのメモリ領域をつかていたセグメンテーションに対して、ページングでは大量の小さい固定サイズのメモリ領域を使う。このとき厳密にはメモリ断片化は起こっているものの、デフラグメンテーションする必要がなく断片化の量も予想できるため、セグメンテーションにおける断片化（外部断片化）に対して優れている。

### ページテーブル

最大で数百万のページを、それぞれ独立にフレームに対応づけるため、この対応関係をどこかに保存する必要がある。セグメンテーションでは、有効なメモリ領域ごとに個別のセグメントセレクタを使っていたが、ページングではレジスタよりも遥かに奥のページが使われるためこれは不可能となる。
代わりにページングでは、ページテーブルという表構造を使って対応関係の情報を保存する。

ページテーブルのカラムには仮想メモリ、対応するフレーム、（アーキテクチャによっては）アクセス権限などのフラグなどがある。

### 複数層（Multilevel）ページテーブル

1層からなるページテーブルは、アドレス空間が大きくなってくると無駄なエントリが発生し、必要以上にテーブルが大きくなってしまうという問題がある。これに対して、それぞれのアドレス領域に異なるページテーブルを使い、ページテーブルを多層化することができる。このとき対応付けのないメモリ領域のためのレベル１テーブルを作る必要がなくなり、ページテーブルを効率的に保持することができる。

## x86_64におけるページング

x86_64アーキテクチャでは4層ページテーブルを使っており、ページサイズは4KiBである。それぞれのページテーブルは層によらず512のエントリを持っている。それぞれのエントリの大きさは8バイトなので、各テーブルは512×8B=4KiBとなり、ぴったり1ページに収まる。

### ページテーブルの形式

x86_64アーキテクチャにおけるページテーブルは、詰まるところ512個のエントリの配列と言える。

```rust
#[repr(align(4096))]
pub struct PageTable {
    entries: [PageTableEntry; 512],
}
```

Rustの構文では上記で表される。`repr`属性より、ページテーブルがアラインされ、ページ一つを完全に使うため、エントリをコンパクトに保持する最適化が可能になる。

それぞれのエントリは8バイト（64ビット）の大きさであり、以下の情報を保持する。

| ビット | 名前 | 意味 |
|:--|:--|:--|
| 0 | present | このページはメモリ内にある |
| 1 | writable | このページへの書き込みは許可されている |
| 2 | user accessible | 0の場合、カーネルモードのみこのページにアクセスできる |
| 3 | write through caching | 書き込みはメモリに対して直接行われる |
| 4 | disable cache | このページにキャッシュを使わない |
| 5 | accessed | このページが使われているとき、CPUはこのビットを1にする |
| 6 | dirty | このページへの書き込みが行われたとき、CPUはこのビットを1にする |
| 7 | huge page/null | P1とP4においては0で、P3においては1GiBのページを、P2においては2MiBのページを作る |
| 8 | global | キャッシュにあるこのページはアドレス空間変更の際に初期化されない（CR4レジスタのPGEビットが1である必要がある） |
| 9-11 | available | OSが自由に使える |
| 12-51 | physical address | ページ単位にアラインされた、フレーム又は次のページテーブルの52bit物理アドレス |
| 52-62 | available | OSが自由に使える |
| 63 | no execute | このページにおいてプログラムを実行することを禁じる（EFERレジスタのNXEビットが1である必要がある） |

今回は`x86_64`クレートがページテーブルとそのエントリのための型を提供しているので、これらの構造体をゼロから作る必要はない。

## 実装

これまでに作ったカーネルでは、すでにページングは実装されている。現在利用しているブートローダは、すでにこれまで製作したカーネルの全てのページを物理フレームに対応づけるような4ページ階層構造を設定している。

つまり、これまでカーネルで使ってきた全てのメモリアドレスは仮想アドレスだった。アドレス`0xb8000`にあるVGAバッファへのアクセスが美味くっていたのは、ブートローダがこのメモリページを口頭対応させていた、つまり仮想ページ`0xb8000`を物理フレーム`0xb8000`に対応させていたからである。

### ページテーブルへのアクセス

`x86_64`クレートの`Cr3::read`関数は、現在有効なレベル4ページテーブルを`CR3`レジスタから読み取って返す。これによってレベル4ページテーブルを確認することができる。

このテーブルに、製作したカーネルからアクセスできるかを考える。ページングが有効なとき、物理メモリに直接アクセスすることはできない。仮にできたとすると、プログラムがメモリ保護を回避して他のプログラムのメモリにアクセスできてしまうからである。

なので、テーブルにアクセスする唯一の方法は、アドレスの物理フレームに対応づけられている仮想ページにアクセスすることとなる。ページテーブルの存在するフレームへの対応付けは、実用上も必要な一般的な問題である。例えば、新しいスレッドのためにスタックを割り当てるときなど、カーネルは日常的にページテーブルにアクセスする必要がある。


---

個人学習用のメモ。オリジナルのブログ投稿は[phil-opp/blog_osにてCC-BY-NC](https://github.com/phil-opp/blog_os/tree/main/blog/content#license)で公開されている。
